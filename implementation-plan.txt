# Spring AI MCP Server Implementation Plan

## Request Summary
Build a Spring AI based MCP Server that:
- Takes a customer ID as input
- Queries a database instance (orders table joined with order_details table)
- Returns order data with product information
- Runs on Cloud Foundry with standalone mode for testing
- Uses specified versions from versions.txt

## Version Constraints
- Spring Boot 3.4.5
- Java 21
- Spring AI 1.0.0
- Spring Cloud 2024.0.1
- Maven

## Initial Plan

### Architecture Overview
1. **MCP Server Core**: Spring Boot application with MCP protocol implementation
2. **Database Layer**: JPA/Hibernate with Spring Data JPA for database operations
3. **AI Integration**: Spring AI for intelligent query processing
4. **Cloud Foundry Support**: Configuration for CF deployment
5. **Standalone Mode**: Local development and testing capabilities

### Database Schema Design (Realistic E-commerce)

#### Core Tables
```sql
-- Customers table (for reference)
customers:
- customer_id (PK, BIGINT)
- email (VARCHAR(255), UNIQUE)
- first_name (VARCHAR(100))
- last_name (VARCHAR(100))
- phone (VARCHAR(20))
- created_at (TIMESTAMP)
- updated_at (TIMESTAMP)

-- Orders table
orders:
- order_id (PK, BIGINT)
- customer_id (FK -> customers.customer_id, BIGINT)
- order_number (VARCHAR(50), UNIQUE) -- e.g., "ORD-2024-001234"
- order_date (TIMESTAMP)
- status (ENUM: 'PENDING', 'CONFIRMED', 'PROCESSING', 'SHIPPED', 'DELIVERED', 'CANCELLED')
- subtotal (DECIMAL(10,2))
- tax_amount (DECIMAL(10,2))
- shipping_amount (DECIMAL(10,2))
- total_amount (DECIMAL(10,2))
- shipping_address_id (FK -> addresses.address_id, BIGINT)
- billing_address_id (FK -> addresses.address_id, BIGINT)
- payment_method (VARCHAR(50)) -- 'CREDIT_CARD', 'PAYPAL', 'BANK_TRANSFER'
- payment_status (ENUM: 'PENDING', 'PAID', 'FAILED', 'REFUNDED')
- notes (TEXT)
- created_at (TIMESTAMP)
- updated_at (TIMESTAMP)

-- Order Details table
order_details:
- detail_id (PK, BIGINT)
- order_id (FK -> orders.order_id, BIGINT)
- product_id (FK -> products.product_id, BIGINT)
- product_name (VARCHAR(255)) -- denormalized for performance
- product_sku (VARCHAR(100))
- product_description (TEXT)
- quantity (INT)
- unit_price (DECIMAL(10,2))
- discount_amount (DECIMAL(10,2))
- line_total (DECIMAL(10,2))
- created_at (TIMESTAMP)

-- Products table (for reference)
products:
- product_id (PK, BIGINT)
- sku (VARCHAR(100), UNIQUE)
- name (VARCHAR(255))
- description (TEXT)
- category_id (FK -> categories.category_id, BIGINT)
- price (DECIMAL(10,2))
- sale_price (DECIMAL(10,2))
- stock_quantity (INT)
- is_active (BOOLEAN)
- created_at (TIMESTAMP)
- updated_at (TIMESTAMP)

-- Addresses table (for reference)
addresses:
- address_id (PK, BIGINT)
- customer_id (FK -> customers.customer_id, BIGINT)
- address_type (ENUM: 'SHIPPING', 'BILLING', 'BOTH')
- first_name (VARCHAR(100))
- last_name (VARCHAR(100))
- company (VARCHAR(255))
- address_line1 (VARCHAR(255))
- address_line2 (VARCHAR(255))
- city (VARCHAR(100))
- state (VARCHAR(100))
- postal_code (VARCHAR(20))
- country (VARCHAR(100))
- phone (VARCHAR(20))
- is_default (BOOLEAN)
- created_at (TIMESTAMP)
- updated_at (TIMESTAMP)
```

#### Sample Data Structure
```json
{
  "order_id": 12345,
  "customer_id": 67890,
  "order_number": "ORD-2024-001234",
  "order_date": "2024-01-15T10:30:00Z",
  "status": "SHIPPED",
  "total_amount": 299.99,
  "order_details": [
    {
      "product_id": 101,
      "product_name": "Wireless Bluetooth Headphones",
      "product_sku": "WH-001",
      "product_description": "Premium noise-cancelling wireless headphones with 30-hour battery life",
      "quantity": 2,
      "unit_price": 149.99,
      "line_total": 299.98
    },
    {
      "product_id": 102,
      "product_name": "USB-C Charging Cable",
      "product_sku": "CC-002",
      "product_description": "High-speed USB-C to USB-C cable, 6ft length",
      "quantity": 1,
      "unit_price": 0.01,
      "line_total": 0.01
    }
  ]
}
```

## Clarifications Received

### 1. Database Configuration ✅
- **Production**: PostgreSQL (Cloud Foundry)
- **Testing**: H2 in-memory database
- **Service Binding**: `orders-db` for Cloud Foundry
- **Database Access**: Direct JPA/Hibernate with Spring Data JPA

### 2. MCP Protocol Details ✅
- **Spring AI 1.0.0 MCP Support**: Use Spring AI's built-in MCP server capabilities
- **Single Function**: Customer ID query only
- **Reference**: [Spring AI MCP Documentation](https://docs.spring.io/spring-ai/reference/api/mcp/mcp-overview.html)

### 3. AI Integration Scope ✅
- **Spring AI MCP Server**: Leverage Spring AI's MCP server implementation
- **Focus**: Query processing and intelligent data retrieval
- **No additional AI features**: Keep it simple for demo

### 4. Cloud Foundry Configuration ✅
- **Service Binding**: `orders-db` for database connection
- **Standard CF deployment**: Use manifest.yml
- **Environment variables**: For database configuration

### 5. API Design ✅
- **MCP Protocol Only**: No additional REST endpoints needed
- **Authentication**: Optional for demo, can be added later
- **Simple Demo Focus**: Keep it minimal and functional

## Database Setup Policy

- The MCP server does NOT create or migrate the database schema, nor does it load data.
- Schema creation and data population are handled externally (e.g., by DBA, CI/CD, or provided shell scripts).
- The MCP server expects the database to be ready and populated at startup.
- If the schema or data are missing, the server will fail fast and log a clear error.

## External Setup Scripts

- Shell scripts are provided to:
  - Create the schema (using the provided SQL migration files)
  - Load sample data into the database
- See the README for instructions on using these scripts.

## Step-by-Step Implementation Plan

### Phase 1: Project Setup and Foundation
1. **Create Maven Project Structure**
   - Initialize Spring Boot 3.4.5 project
   - Configure Java 21
   - Set up parent POM with version management
   - Add Spring AI 1.0.0 dependencies
   - Configure Spring AI MCP server dependencies

2. **Database Schema and Models**
   - Create JPA entities for orders, order_details, customers, products, addresses
   - Set up database configuration (H2 for local, PostgreSQL for CF)
   - Create repository interfaces with Spring Data JPA
   - Add database migration scripts (Flyway or Liquibase)
   - Create sample data for testing

3. **Spring AI MCP Server Setup**
   - Configure Spring AI MCP server components
   - Create customer query tool/function
   - Set up MCP protocol handlers using Spring AI
   - Add error handling and validation
   - Configure MCP server properties

### Phase 2: Core Functionality
4. **Database Integration**
   - Implement order query service with Spring Data JPA
   - Create join queries for orders + order_details + products
   - Add customer ID validation and error handling
   - Implement data transformation layer for MCP responses
   - Create comprehensive order DTOs

5. **Spring AI MCP Tool Implementation**
   - Create MCP tool for customer order queries
   - Implement tool function with Spring AI annotations
   - Add intelligent query processing and data formatting
   - Configure tool metadata and descriptions
   - Add parameter validation and error handling

6. **MCP Server Configuration**
   - Configure Spring AI MCP server properties
   - Set up tool registration and discovery
   - Implement proper JSON-RPC communication
   - Add comprehensive error handling
   - Create MCP server health checks

### Phase 3: Testing and Configuration
7. **Testing Framework**
   - Unit tests for services
   - Integration tests for database
   - MCP protocol tests
   - AI functionality tests

8. **Standalone Mode Configuration**
   - Local development setup
   - H2 in-memory database for testing
   - Configuration profiles
   - Development tools and scripts

### Phase 4: Cloud Foundry Deployment
9. **Cloud Foundry Configuration**
   - Create manifest.yml
   - Environment-specific configurations
   - Service bindings setup
   - Health checks and monitoring

10. **Production Readiness**
    - Logging configuration
    - Metrics and monitoring
    - Security configurations
    - Performance optimization

### Phase 5: Documentation and Deployment
11. **Documentation**
    - API documentation
    - MCP protocol documentation
    - Deployment guides
    - Configuration reference

12. **Final Integration and Testing**
    - End-to-end testing
    - Performance testing
    - Security testing
    - Production deployment validation

## Next Steps
1. Review and approve this plan
2. Answer clarification questions
3. Begin with Phase 1: Project Setup
4. Work through each phase systematically

## Success Criteria
- MCP server responds to customer ID queries
- Database queries return complete order information
- Spring AI integration provides intelligent processing
- Application runs on Cloud Foundry
- Standalone mode works for development/testing
- All version constraints are met
- Comprehensive test coverage
- Production-ready deployment 